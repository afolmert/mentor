\documentclass[a4paper,11pt]{article}
\newcommand{\smite}{\emph{\textbf{Smite{}}}}
\usepackage{graphicx}

\begin{document}

% do: set formatoptions+=t to have it formatted
% set tw=79

%TODO
%How to put text in special font (code font?)
%Right now put it as \\begin and \\end and later change to something else
% how to automatically fill regions
% when editing tex/latex files
% how to give header page
%How to make references to other part of the document??
%Is it possible to generate html/xml and chm and man/info pages out of it?
%I would like to have only one document for edition but which will generate a
%series of documents
%Why is the margin so big?
%The smite name should be in capitals instead
%Check out how python doc is done - how do they generate their documentation??





% {{{1 Introduction
%

\section{Introduction}

\smite{} is a tool for extracting and rearranging knowledge from documents in
a way which makes it more suitable for understanding and learning. It uses a
special markup language to mark the interesting parts of a document
and then extracts those parts and presents them in way that can be exported
to flash-card programs like SuperMemo, Mnemosyne or Mentor.

For example, let's assume here is a text you want to get some info from:
\textit{Christoph Columbus was a great adventurer. America was discovered by
Columbus in 1492.}

If you want to learn the important facts from given text, you modify it
slightly by adding smite markup:
\begin{verbatim}
\begin{cloze}
Christoph Columbus was a \?{great adventurer}. America was discovered by
\?{Christoph Columbus} in \?{1492}.
\end{cloze}
\end{verbatim}

Running smite over thusly modified text, will result in the following:
\begin{verbatim}
q: Christoph Columbus was a ....
a: great adventurer

q: America was discovered by ... in 1492
a: Christoph Columbus

q: America was discovered by Christoph Columbus in ...
a: 1492
\end{verbatim}

The resulting items may now be exported to a flashcard program for memorizing.

Smite can be also used to quickly prepare knowledge cloze tests over a wide
range of different texts, like: programming code, articles etc.



-- sense of flashcard programs ---

If you never met a flashcard program before : it is a tool presenting knowledge
in a form of cards. On each card there is stored one item which is repeatedly
presented to you, until all knowledge is remembered.

The most known example of such program is SuperMemo designed by Piotr Wozniak.


SuperMemo is a program for improving the learning process by keeping track of
your repetition schedule. It's mainly used in foreign language study, although
it can be applied to any kind of knowledge.

It is a great way of learning but it presents a special problem: how to
construct the knowledge ...?

TODO here add some more

The idea of the program is to split the knowledge into distinct items with a
question and answer e.g. \emph{Q: mother A: die Mutti} for german vocabulary
item or \emph{Q: when did II World War begin A: 1939} for historical item.  The
user has to review the items regularly by looking at the questions and trying
to come up with the answer in his head. Then the program displays the answer
and user has to assign himself a score basing on the quality of his answer.
Then the item is scheduled to be reviewed in some future time and user selects
another item and so on.

The great part about SuperMemo is the scheduling algorithm which tries to
optimize the time break needed for next review, basing on user-assigned score,
item difficulty, general user profile and database difficulty. The optimal
schedule time is just before the item is about to be forgotten so that the
review provides most benefits to user memory and items are not stacked up too
quickly.  It is not uncommon for SuperMemo users to have tens of thousands of
items in their databases and yet not spending more than a couple of minutes
each day to have the scheduled items reviewed.




%====================
\subsubsection{\smite{} goal}

The purpose quickly generating lots of items for supermemo  and i'm testing
this great purpose editor and i'm not sure how it works



Generally I should be able to just paste cheatsheet then apply some little/mall
markup rules to better transform learning process There should be as little
changes to the original texts as possible - the XML markups just go out of
question

I will create cheatsheets and out of this cheatsheets -> just a little command
to generate supermemo items as well

The stynax colors should make the additional words not really visible just like
ocmments The idea The syntax is generally based on TEX/LATEX markups


The most time-consuming part of SuperMemo usage is the creation of those item
databases. There already exist plenty of ready-made database for most foreign
languages (on different difficulty levels) and for common knowledge areas like
geography, literature etc. but it is often useful or required to create
custom-made databases. This is especially true for non-language databases, e.g.
when one wants to learn facts from some articles or tutorials. Manual input of
data to SuperMemo is quite cumbersome and impractical if one wants to learn
lots of knowledge.

This is the gap that this \smite{} program is trying to fill.

The aim of this tool is to automatically extract valuable knowledge from texts
and presents them in format which can be readily imported to SuperMemo. The
extraction process can be fully customized by using a simple markup language
which you may put in the text to annotate which fragments must be exported and
in what way should they be presented in SuperMemo.


the aim of this tool is to generally tweak all the way it's used gr

%====================
\subsubsection{\smite{} name}

Most specifically, \smite{} is a tool to automate creation of SuperMemo items.
The name is abbreviation for \emph{SuperMemo EXport}.

This should really go in the reference below: for one SMITE is an acronym for
SuperMemo ITEms which is a common-sense name for SuperMemo add-on tool.  The
second meaning might be in \emph{smiting dark evil} which is a metaphore for
bringing light to dark minds and trying to lighten the path of no-knowledge.
And the last which comes to my mind is , obviously, the required recursive
acronym name which may be \emph{smite is the elite} or \emph{smite might
include teaching erudite}.  This is just a crude comment, please don't take it
too seriously.. .




% 1}}} Introduction
% {{{1 Usage
\section{Usage}

\smite{} is a command-line utility and it's basic usage involves just running the
script from the shell with a parameter of text file you want to export:
\begin{verbatim}
smite article.txt
\end{verbatim}

This will print the items for the file to the screen. If you want to save those
items in a kind of file, you could run:
\begin{verbatim}
smite article.txt > article.out
\end{verbatim}
and then the file article.out will be generated.
It can be imported to SuperMemo by selecting from menu:
File->Tools->Import->Q\&A text
The items will then appear in a new SuperMemo branch.


In it's default configuration, \smite{} will export all paragraphs from the
file, creating one item for each word in paragraph, resulting in cloze
items:
e.g. from paragraph:
\begin{verbatim}
The World War II broke in 1939 year.
\end{verbatim}
the following items will be created:

\begin{verbatim}
Q: The ... II broke in 1939.
A: World War

Q: The World War ... broke in 1939.
A: II

Q: The World War II broke in ....
A: 1939
\end{verbatim}

The common words like \textit{the}, \textit{broke} and \textit{in} are ignored
from the cloze to avoid creation of too many unecessary items.

In order to customize what should be exported from the file and how the
items should be created you can use a special markup language to annotate the
file.  The markup language gives hints to \smite{} how it should export the
text.
In it's default state, \smite{} will try deduce the format of the given file
and export items in most useful state. If you want to control what items are
exported you have to modify the file contents, using special smite markup
language (called smite as well).


Smite default behaviour may be often inappropriate and you may want to
customize it. Smite command-line interface provides numerous options and switches

\subsubsection{Options and switches}
There are a set of command-line options which may be used to control smite
behaviour:

Here are the most common configuration options:

--quick -q tries to parse text intelligently without any markup

--debug -d writes debug output

--verbose -v writes verbose information

--swap=off/on should generate swapped items as well?

--class = tries to use given class when parsing the file

The currently supported classes are: tabular, cloze, sentences, paragraphs,
code and graphical.

The switches and options provided by Smite command-line interface may be often
now enough. In some cases a more fine-grained control may be needed.
In order to have full control over smite export, you will have to modify the
document, using simple smite markup language.

% 1}}} Usage
% {{{1 Smite markup language
\section{Smite markup language}
%{{{2 Introduction
\subsection{Introduction}
It may happen that the defaults used by \smite{} are not sufficient to extract
to knowledge or you may want to tweak the questions and answers generated by
\smite{} so that you can memorize them more easily.

To achive this you may want to use the smite markup language.

% write about what are markup languages like SGML, HTML and LaTeX family smite
% tries to be as minimal and unobtrusive as possible and yet poweful to be able
% to tweak the way in which items are imported.


The basic design goal of the smite language was to make it as unobtrusive as
possible - so that I could use the files as a real cheatsheet - yet make it
quite powerful and expressive so that I could specify exactly what I want to
learn from given piece of text.


The basic requirement I have for \smite{} is to be as efficient as possible
when extracting the information from text.

The requirement means that it should be as minimalistic as possible, so that I
can e.g. take an existing cheatsheet, add some annotations and it will be
exported correctly. I don't want to spend day by tweaking the document to have
a desired result.

In no mood to reinvent the wheel I modelled the language mainly after LaTeX as
it's quite lightweight. Of course it is not a proper LaTeX syntax and cannot be
processed by latex tools - it only has some superficial similarities which make
easier for people familiar with LaTeX to start using it right away.  I also
added some special tweaks and shortcuts after currently popular light-html
markups like markdown and textile to make the language even more lightweight.

- requirements for language: minimalistic - extracting information in a subtle
way

Smite markup language is a special language for marking text in a way that can
be understood by Smite. It is superficially smiliar to such languages like TeX,
HTML or currently popular languages like Markdown etc.

It is quite a forgiving language - it uses the same idea as the web
browsers - it tries to parse what it can parse, and in case of errors it tries
to deduce the best meaning. It has also the strict option which makes it
possible to detect the errors quickly.

The Smex language is not one language - it is specifically a collection of
different languages - each one being a specific class.

They are called classes and determine how the text should be processed. The
classes share some similarities (e.g. option settings) but generally each class
tries to blend with the type of text it tries markup.

It is superficially similar to LaTeX.


% 2}}}
% {{{2 General constructs
\subsection{General constructs}

%====================
\subsubsection{FIXbegin and FIXend options}
The most general construct is FIXbegin and FIXend. They mark the beginning of
special class which is used to parse the text contained in it.

It determines what class should be chosen for parsing the file.

The class may be one of the following:
\emph{tabular}, \emph{sentence}, \emph{code} and \emph{qa} and others which
will be described later.

This construct may contain option settings in [ ]:
the possible options are \emph{swap} , \emph{prefix}, \emph{mainprefix} and
others.


The construct of chosing class is similar to what we call environment in LaTeX
(again similarly to LaTeX):

TODO must select different font for these to work !!!!

1. \char92 items construct This is the basic construct which marks the text to
be processed by \smite{}. By default \smite{} processes the whole file unless it
encounters this construct - then only the text between those tags is processed
and the text outside this construct is ignored.

\char92 items{class}[options]
\char92 enditems{class}

The {class} determines the type of export \smite{} should use. Currently
there are several types of export and each one treats the

A class determines how the text should be treated. It determines the rules ,
class and algorithm that is selected to process given text chunk.  It is
possible to extend \smite{} with custom classes whenever you feel there are
some texts you would like to learn in a special way or modify existing classes
by deriving from them and creating new classes.

%====================
\subsubsection{FIXinclude option}
This option is used to include another file in the current in current file.

It is similar to C/C++ preprocessor directive which includes the content of
another file in given file.
This may be useful when you want to have your articles nicely splitted among
different files but want to have only one file to process.

Example usage:
\begin{verbatim}
\begin{set}
\include{sample.txt}
[...]
\end{verbatim}

This will include sample.txt file to the currently processed file.
Note that the processing will be done according to currently active options. In
this case, the file will be processed as \textit{set mode}.

The file must be present in current path or in PATH variable.

%====================
\subsubsection{FIXcommon option}
This construct includes common words in current scope which should be skipped
when asking questions in Set class.
Basically, the Set class will ask for each word which exists in sentence. If
you include common words, they will not be asked for.

This section is valid in Set classes. TODO reference.


Example usage:
\begin{verbatim}
\common{common.txt}
\end{verbatim}

The file must be included in the path or in current directory.


%====================
\subsubsection{FIXlang option}
This will determine the language used in export. This is especially important
because it determines the common words which should be excluded from Set
questions.

Example usage:
\begin{verbatim}
\lang{en}
\end{verbatim}

Currently possible values are: \textit{en} and \textit{pl}.



%====================
\subsubsection{FIXjoined option}
This option includes a file with joined words which should not be split when
asking for words in Set class.
By default, all words with capital letters are joined if they happen to exist
side by side.

The file contents should be like this
\begin{verbatim}
file contents
stored eventually
\end{verbatim}

ie in each line should be words which should be connected if they happen to
exist exactly in this way.

Example usage:
For the following instructions:
\begin{verbatim}
\joined{joined.txt}
\begin{set}
The file contents is empty.
\end{set}
\end{verbatim}
smite will generate the questions:
\begin{verbatim}
q: The ... is empty.
a: file contents

q: The file contents is ....
a: empty.
\end{verbatim}

Notice that there were no double questions generated for \textit{file} and
\textit{contents} but they were merge into one.

%====================
\subsubsection{FIXcomment}
The comment in smite is done similarly to LaTeX: using the \% char.
Everything that is preceded by this char is commented.
Note that if you want to have this char, you must escape it, using backslash
character.

%====================
\subsubsection{FIXmode}
The mode command determines how text should be processed. Possible values are
\textit{approx}, \textit{normal} and \textit{strict}. In \textit{approx} mode,
the language is as forgiving as possible - all possible options and formats are
deduced from the file and no errors are raised.
In \textit{normal} mode, only serious errors (like missing file) cause
\smite{} stoppage and all other errors are just reported as warnings.
In \textit{strict} mode, every little warning generates an error which stops
further processing.

The \textit{approx} mode is useful when we want to get around a file and have
some results quickly.
The \textit{strict} mode is useful when we want to be sure than any
errors go unnoticed. This is usually useful in the last iterations, when we
fixed all possible problems with given file.


Example usage:
\begin{verbatim}
\mode{strict}
\end{verbatim}

It is possible to have different modes in file. All text processed after mode
command, will be treated as it said.
These values may be also set from the command-line using option -mode
See:  TODO ref


% 2}}} General constructs
% {{{2 Tabbed class
\subsection{Tabbed class}

In \textit{tabbed class}, each line is treated as an item. The question is everything
before tab, and answer everything after tab.
Only the first tab occurrence is taken into account, all others are ignored.
If not tab exists in a line, then the whole line is treated as an question and
answer stays empty. If the mode is strict, this will raise an error.

Empty lines are ignored completely.
If you have items which are longer than one line, you can use the backslash
character at the end of line to show the line will be merged.

Example:
\begin{verbatim}
\begin{tabbed}
What's the capital of Angola?TABAngola
America was discovered byTABAmerigo/ Vespucci
\end{tabbed}
\end{verbatim}

will result in:
\begin{verbatim}
q: What's the capital of Angola
a: Angola

q: America was discovered by
q: ... Vespucci
a: Amerigo Vespucci

q: America was discovered by
q: Amerigo ...
a: Amerigo Vespucci
\end{verbatim}


The whole right part of the line (after tab) is taken as an answer.
If you want to have the answer splitted into many parts, and thus more items
generated, then you must use the / char.

Options which may be used here:
\textit{swap} options which determines whether to generate




% 2}}} Tabbed class
% {{{2 QA class
\subsection{QA class}
This is very similar to \textit{Tabbed class} with only difference being that
each items consist of 2 lines of separate paragaphs. They are seperate by the
\emph{enter} char.

This may be useful when the lines are too long to displayed side by side, as it
is in \emph{Tabbed class}.
All other options of \emph{Tabbed class} apply here as well.

Example:
\begin{verbatim}
\begin{qa}
America was discovered by
Amerigo/ Vespucci

What's the capital of Angola
Angola
\end{qa}
\end{verbatim}

The above code will result in the following items:
\begin{verbatim}
q: America was discovered by
q: Amerigo ...
a: Amerigo Vespucci

q: America was discovered by
q: ... Vespucci
a: Amerigo Vespucci

q: What's the capital of Angola
a: Angola
\end{verbatim}


Note that the generated items are virtually the same as the items generated
from \emph{Tabbed class}.

% 2}}}A QA class
% {{{2 Cloze class
\subsection{Cloze class}
% 2}}}A Cloze class
% {{{2 Comma-seperated class
\subsection{Comma-seperated class}
This class is similar to tabbed class but uses commas instead of TAB
characters.

e.g. this text will be transformed:


% 2}}}A Comma-seperated class
% {{{2 Set class
\subsection{Set class}
% 2}}}A Set class
% {{{2 Code class
\subsection{Code class}

This is a general class which may be used to generate items out of programming
constructs. It may be useful if one wants to memorize some function signatures.

It may seem unnecessary in XX century when you have intellisense everywhere,
but sometime it is better to keep code in ones head, and besides intellisense
is not available eveywhere.

By default it will try to use heuristics to recognize the language used -
sometimes however the heuristics may not work and you may give an option to the
code class.  Currently the following languages are supported:

\begin{verbatim}
options: [lang=c/pascal/java/javascript/python] etc.  signatures the code
itself as well or not ?
\end{verbatim}



% 2}}}A Code class
% {{{2 Sentence class
\subsection{sentence class}

This is the most general class which is suitable for pure articles.  It will
just extract each sentence and try to extract important information from it.

It will go paragraph by paragraph.

By it's design smxe


% 2}}} Sentence class
% {{{2 Graphical class
\subsection{graphical class}
\smite{} will work with graphical items as well as text items will export to su
SuperMemo ITEms Tools .  Graphical repetitions work by selecting a fragment of
a picture and trying to remember what the cloze was about.  Currently export of
graphical class to SuperMemo is limited but the Mentor program works with it
quite well.

The syntax is as follows:

\begin{verbatim}

\begin{graphics}graphics{hello.bmp}
\pic[10,20]
\pic[10,30,50,50]
\end

\end{verbatim}
% 2}}} Graphical class
% {{{2 Options
\subsection{Class options}

Each class has a set of options which may be used to tweak it's mechanizm.
Generally options are used to modify the class in a slight way - if you want
some bigger changes then you should use another class.


% {{{3 swap option
\subsubsection{swap option}

This option determines whether the items should be swapped or not. By default,
\smite{} will generate one question and answer out of items in sentence or tab
class.  If you want the opposite question and answer to be generated, you
should set this option.

\begin{verbatim}

options:
 [swap]
 [noswap]
   should the item be swapped ?
   when questioning?
   e.g.
   what is your subject?
   maths

   when swapped this will translate to ->
   q: what is your subject?
   a: math
   and swapped question:
   q: math?
   a: what is your subject

   [TODO] find a better example


\end{verbatim}

% 3}}}

% 2}}} Options
% {{{2 Special constructs
\subsection{Special constructs}

This subsection describes special constructs which may be used all over the
file, in almost all classes.
Warning! Appearance of some special constructs determines the class /??


%====================
\subsubsection{The \^ char}
The joining char is used to join words which should be used together.
This is especially useful for Set class which asks for each word in given text.


When words will be joined with \^ , .eg. \textit{America was discovered by
Christoph\^Columbus} then
In Set class, this would result in asking for each word seperately. By joining
Christoph Columbus in one it will appear only once in answer.

Note: some words are joined automatically. E.g. words beginning with capitals
near themselves are automatically joined.

The is also FIXjoined command and special char \ FIXbackslash which will split
them


%====================
\subsubsection{The ! char}
The ! char describes the word following it should be excluded from the export.
It is useful also in the Set class, which selects all words from given text.


%====================
\subsubsection{The / char}
This is the 'przeciwienstwo' of the \^ char which would join - it would split
the names. It is useful also in the Set class questioning - when you want to
split despite the default rules being joining the words with capitals.


%====================
\subsubsection{The \\ char}
This char is used at the end of line to denote multi-line statement.
If in \textit{strict} mode, then no white chars may appear after it.

This may be useful when e.g. in Tab mode we want to have item which is quite
long but we want it to appear on the screen. So we put it in many lines and by
using the \\ char we ensure it will be treated as one char.

% 2}}}
% 1}}} Smite markup language
% {{{1 Examples
\section{Examples}
This section presents examples of \smite{} usage in order to better present
it's usage language.



% 1}}} Examples
% {{{1 Other applications

\section{Other applications}

Other apps which I based myself on are:
\begin{enumerate}

\item[SuperMemo] this is THE program for making repetitions. It is
  traditionally geared more towards learning language than for any other
  purpose.

\item[Mnemosyne]this is an opensource version of SuperMemo , written in
Python and Qt. It is also geared towards word learning and therefore it
is not very suitable for my needs. It certainly was an inspiration
though.

\item[Mentor] this is another program which may be used to quickly test knowledge prepared by \smite{}.
It's developed by \smite{} author so integration with it is quite simple.

\end{enumerate}

% 1}}} Other applications
% {{{1 Feedback
\section{Feedback}
This is initial release of this script - it is far from perfect and may
contain several bugs.
If you notice any bugs or have any comments about this program, please
send info to: santhalus AT gmail DOT com


% 1}}} Feedback
%{{{1 older stuff


%
%pocz¦tek : integracja narzàdzi dostàpnych : Visio i SuperMemo
%dodaje Add-Iny dopisujà elementy import / export
%
%
%zale¬y ile da sià zrobiŠ w tym visio
%potem moge add-iny pisac w c++
%
%
%potem, jeli projekt sià powiedzie i bede tego u¬ywa-
%--> mo¬e przepiszà to na w-asne narzàdzie uzywaj¦c
%Borland C++ + CLX i Pythona jako rozszerzenia (do implementowania prototyp¡w)
%
%albo
%Java i Jython
%
%
%
%
%
%--------------------------
%---------------------------
%MENTOR TODO
%---------------------------
%
%
%Mentor new version : in emacs
%set of macros
%mentor minor mode
%perparing texts for supermemo and testing for supermemo
%extract sentence , and add to database , making it a question
%
%plus
%set of shell/python  scripts for
%extracting knowledge from pascal, c etc sources
%and converting to supermemo knowledge
%maybe using emacs snavigator for analyzing source code ??
%
%
%
%allowing :
%set of macros for preprocessing  a text
%extracting important information from plsql code for example
%
%e.g.
%function name1
%function name2
%function name3
%
%
%
%
%
%testing in formats:
%q:
%q:
%a:
%a:
%
%or html like (instead of my . language )
%<q>  <a>
%
%<q bimode>
%procedure dosomething
%<a>
%tworzy
%
%<style pascal bimode>
%
%</style>
%
%
%Also performing gap text test e.g.
%blanking out and showing all of given words randomly
%or I can mark by myself the words which I want to be tested
%
%create table XMIGPROPS_V32
%(
%  OBJECTID       NUMBER,
%  PROPERTY       VARCHAR2(100),
%  VVALUE         VARCHAR2(100),
%  TYTANTABLENAME VARCHAR2(100)
%)
%
%
%  performing different tests :
%  - q and a test like in supermemo on Q A
%
%Check out elip and flashcard modes
%
%
%Export to my graphic supermemo testing ground
%MySupermemo
%
%Graphics SuperMemo may be done as a extension to Visio SDK
%with objects that will disappear ?? or better bitmap ??
%it would be nice to have such access to supermemo that I can export and not
%touch it anymore
%
%



%For most

%Ad 2. Markup language  Mentor markup language the purpose of markup language
%is help for generating repetition items quickly.




%cheatsheets to supermemo

%1. General options
%[prefix="ale"]

%1. Headers
%2. Different classes
%I will have different classes for different formatting cases.


%*** class CODE

%*** class CLOZE
%This class describes a typical cloze questions

%*** class SET




%*** class


%2. Special directives

%\include{file}[name]
%this includes a file to the current file

%\compounds{file}
%This options means to include a file with compounds e.g. item which
%always go together and should be treated as such . Generally, all words
%with capital letters one by one are treated as compounds.


%\ex
%\bold \
%the text up till end should be bold
%??
%this will be better with *text*

%\item
%\enditem
%This will mean I want all the text as one item
%By default items will be seperated by one blank line
%but if I want several pars to be one item , I can put this one

%\
%at the end of line , this directive will join both lines to one
%(just like c preprocessor)


%3. Shortcuts aka special chars
%There will be a set of special chars which will modify the meaning and
%give some clues for extraction purpose.



%^   ignored word
%this means the word will not be included in repetitions
%~  joined words
%?   words to be selected

%General rule for character ? and ^:
%their appearance in text determines whether I should rather exclude or
%include words: they are also mutually exclusive - this can be checked as
%a test.

%Consider these cases:
%Poland was raised in ?996.

%and
%Poland ^was ^raised ^in 996

%The first one will ask for 996 only. The second will ask for Poland and
%996 as they are not excluded.
%By default I ask for all words (unless the \common directive




%$
%
%^
%'
%"



%the idea is to use as little macros as possible
%I just should use the plain text as it is

%have very different formats to translate from

%y
%the basics



%Ad 3. Mentor GUI
%Mentor GUI is an app written in PyQt.
%I really believe this is the optimal choice for quickly writing
%applications.











%Ad 4.



%DOCUMENTATION FOR MENTOR MARKUP LANGUAGE SYNTAX
%begin{aaa}[some]
%\eq  \eq[a=12][b=12]{this is great}
%kquestion on one ? k

%\begin{table}

%\end{table}

%1100
%sample :
%\end

%\test

%jjjj\
%\beg

%~ joined word

%\great

%<browse> </browse>

%llllll

%\test[section=2][break=minimal]
%\begin

%\end
%begin{tabular}


%\bottom{done}

%\begin{classic}{title="Left right motion"}[prefix=hej][title="Borking"]

%|k|	N  k		up N \quick lines (also: CTRL-P \bold and <Up>)
%|j|	N  j		down N lines (also: CTRL-J, CTRL-N, <NL>, and <Down>)
%|-|	N  -		up N lines, \eq on the first non-blank character
%|+|	N  +		down N lines, on the first non-blank character (also:
                           %CTRL-M and <CR>)
%|_|	N  _		down N-1 lines, on the first \b2 non-blank character
%|G|	N  G		goto line N (default: last line), on the first
                           %non-blank character
%|gg|	N  gg		goto line N (default: first line), on the first
                           %non-blank character \peg{utilitze section}
|N%|	N  %		goto line N percentage down in the file.  N must be
                           given, otherwise it is the |%| command.
%|gk|	N  gk		up N screen lines (differs from "k" when line wraps)
%|gj|	N  gj		down N screen lines (differs from "j" when line wraps)

%"envy and great injustice
%\end

%\begin{sentences}[baz=foo][legend=off]
%Structure is ~what is best known to man.

%The very act of~browsing~history is *essential.



%\end

%\begin{sentences}
%\end

%\begin{csyntax}
%\end



%\par


%\dupa


%\end{documentclass}

%}}}
\end{document}
